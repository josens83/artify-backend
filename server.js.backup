require('dotenv').config();
const express = require('express');
const cors = require('cors');
const path = require('path');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const Database = require('better-sqlite3');
const multer = require('multer');
const { WebSocketServer } = require('ws');
const fs = require('fs');

const app = express();

// CORS ì„¤ì •
app.use(cors({
    origin: '*',
    credentials: true
}));

app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// â­ ì •ì  íŒŒì¼ ì œê³µ (frontend í´ë”)
app.use(express.static(path.join(__dirname, '../frontend')));

// ì—…ë¡œë“œ í´ë” ìƒì„±
const uploadsDir = path.join(__dirname, 'uploads');
if (!fs.existsSync(uploadsDir)) {
    fs.mkdirSync(uploadsDir, { recursive: true });
}

// ì—…ë¡œë“œëœ íŒŒì¼ ì •ì  ì œê³µ
app.use('/uploads', express.static(uploadsDir));

// íŒŒì¼ ì—…ë¡œë“œ ì„¤ì •
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, uploadsDir);
    },
    filename: (req, file, cb) => {
        const uniqueName = Date.now() + '-' + Math.round(Math.random() * 1E9) + path.extname(file.originalname);
        cb(null, uniqueName);
    }
});

const upload = multer({
    storage: storage,
    limits: { fileSize: 50 * 1024 * 1024 }, // 50MB
    fileFilter: (req, file, cb) => {
        const allowedTypes = /jpeg|jpg|png|gif|svg|webp/;
        const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
        const mimetype = allowedTypes.test(file.mimetype);
        if (mimetype && extname) {
            return cb(null, true);
        }
        cb(new Error('Only image files are allowed!'));
    }
});

// ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”
const dbPath = path.join(__dirname, 'canva-clone.db');
const db = new Database(dbPath);

// ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸” ìƒì„±
db.exec(`
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        name TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS projects (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        title TEXT NOT NULL,
        canvas_data TEXT,
        canvas_width INTEGER DEFAULT 800,
        canvas_height INTEGER DEFAULT 1000,
        thumbnail TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id)
    );

    CREATE INDEX IF NOT EXISTS idx_projects_user_id ON projects(user_id);
`);

console.log('ðŸ“ Database initialized at:', dbPath);

// JWT ì‹œí¬ë¦¿
const JWT_SECRET = process.env.JWT_SECRET || 'canva-clone-secret-key-2024';

// ì¸ì¦ ë¯¸ë“¤ì›¨ì–´
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
        return res.status(401).json({ error: 'Access token required' });
    }

    jwt.verify(token, JWT_SECRET, (err, user) => {
        if (err) {
            return res.status(403).json({ error: 'Invalid or expired token' });
        }
        req.user = user;
        next();
    });
};

// ========================================
// ì¸ì¦ API
// ========================================

// íšŒì›ê°€ìž…
app.post('/api/auth/signup', async (req, res) => {
    try {
        const { email, password, name } = req.body;

        if (!email || !password || !name) {
            return res.status(400).json({ error: 'All fields are required' });
        }

        // ì´ë©”ì¼ ì¤‘ë³µ í™•ì¸
        const existingUser = db.prepare('SELECT id FROM users WHERE email = ?').get(email);
        if (existingUser) {
            return res.status(400).json({ error: 'Email already exists' });
        }

        // ë¹„ë°€ë²ˆí˜¸ í•´ì‹±
        const hashedPassword = await bcrypt.hash(password, 10);

        // ì‚¬ìš©ìž ìƒì„±
        const result = db.prepare('INSERT INTO users (email, password, name) VALUES (?, ?, ?)').run(email, hashedPassword, name);

        const token = jwt.sign({ id: result.lastInsertRowid, email, name }, JWT_SECRET, { expiresIn: '7d' });

        res.json({
            token,
            user: { id: result.lastInsertRowid, email, name }
        });
    } catch (err) {
        console.error('Signup error:', err);
        res.status(500).json({ error: 'Server error during signup' });
    }
});

// ë¡œê·¸ì¸
app.post('/api/auth/login', async (req, res) => {
    try {
        const { email, password } = req.body;

        if (!email || !password) {
            return res.status(400).json({ error: 'Email and password are required' });
        }

        const user = db.prepare('SELECT * FROM users WHERE email = ?').get(email);
        if (!user) {
            return res.status(401).json({ error: 'Invalid email or password' });
        }

        const validPassword = await bcrypt.compare(password, user.password);
        if (!validPassword) {
            return res.status(401).json({ error: 'Invalid email or password' });
        }

        const token = jwt.sign({ id: user.id, email: user.email, name: user.name }, JWT_SECRET, { expiresIn: '7d' });

        res.json({
            token,
            user: { id: user.id, email: user.email, name: user.name }
        });
    } catch (err) {
        console.error('Login error:', err);
        res.status(500).json({ error: 'Server error during login' });
    }
});

// ì‚¬ìš©ìž ì •ë³´ ì¡°íšŒ
app.get('/api/auth/me', authenticateToken, (req, res) => {
    try {
        const user = db.prepare('SELECT id, email, name, created_at FROM users WHERE id = ?').get(req.user.id);
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        res.json(user);
    } catch (err) {
        console.error('Get user error:', err);
        res.status(500).json({ error: 'Server error' });
    }
});

// ========================================
// í”„ë¡œì íŠ¸ API
// ========================================

// í”„ë¡œì íŠ¸ ìƒì„±
app.post('/api/projects', authenticateToken, (req, res) => {
    try {
        const { title, canvas_width, canvas_height } = req.body;
        const userId = req.user.id;

        const result = db.prepare(`
            INSERT INTO projects (user_id, title, canvas_width, canvas_height, canvas_data)
            VALUES (?, ?, ?, ?, ?)
        `).run(userId, title || 'Untitled Project', canvas_width || 800, canvas_height || 1000, '[]');

        res.json({
            id: result.lastInsertRowid,
            title: title || 'Untitled Project',
            canvas_width: canvas_width || 800,
            canvas_height: canvas_height || 1000
        });
    } catch (err) {
        console.error('Create project error:', err);
        res.status(500).json({ error: 'Failed to create project' });
    }
});

// í”„ë¡œì íŠ¸ ëª©ë¡ ì¡°íšŒ
app.get('/api/projects', authenticateToken, (req, res) => {
    try {
        const projects = db.prepare(`
            SELECT id, title, canvas_width, canvas_height, thumbnail, created_at, updated_at
            FROM projects
            WHERE user_id = ?
            ORDER BY updated_at DESC
        `).all(req.user.id);

        res.json(projects);
    } catch (err) {
        console.error('Get projects error:', err);
        res.status(500).json({ error: 'Failed to fetch projects' });
    }
});

// í”„ë¡œì íŠ¸ ìƒì„¸ ì¡°íšŒ
app.get('/api/projects/:id', authenticateToken, (req, res) => {
    try {
        const project = db.prepare(`
            SELECT * FROM projects
            WHERE id = ? AND user_id = ?
        `).get(req.params.id, req.user.id);

        if (!project) {
            return res.status(404).json({ error: 'Project not found' });
        }

        // canvas_dataë¥¼ JSONìœ¼ë¡œ íŒŒì‹±
        project.canvas_data = JSON.parse(project.canvas_data || '[]');

        res.json(project);
    } catch (err) {
        console.error('Get project error:', err);
        res.status(500).json({ error: 'Failed to fetch project' });
    }
});

// í”„ë¡œì íŠ¸ ì—…ë°ì´íŠ¸
app.put('/api/projects/:id', authenticateToken, (req, res) => {
    try {
        const { title, canvas_data, canvas_width, canvas_height, thumbnail } = req.body;
        const projectId = req.params.id;
        const userId = req.user.id;

        // í”„ë¡œì íŠ¸ ì†Œìœ ê¶Œ í™•ì¸
        const project = db.prepare('SELECT id FROM projects WHERE id = ? AND user_id = ?').get(projectId, userId);
        if (!project) {
            return res.status(404).json({ error: 'Project not found' });
        }

        // canvas_dataë¥¼ ë¬¸ìžì—´ë¡œ ë³€í™˜
        const canvasDataString = typeof canvas_data === 'string' ? canvas_data : JSON.stringify(canvas_data);

        db.prepare(`
            UPDATE projects
            SET title = ?, canvas_data = ?, canvas_width = ?, canvas_height = ?, thumbnail = ?, updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        `).run(title, canvasDataString, canvas_width, canvas_height, thumbnail, projectId);

        res.json({ success: true, message: 'Project updated successfully' });
    } catch (err) {
        console.error('Update project error:', err);
        res.status(500).json({ error: 'Failed to update project' });
    }
});

// í”„ë¡œì íŠ¸ ì‚­ì œ
app.delete('/api/projects/:id', authenticateToken, (req, res) => {
    try {
        const projectId = req.params.id;
        const userId = req.user.id;

        const result = db.prepare('DELETE FROM projects WHERE id = ? AND user_id = ?').run(projectId, userId);

        if (result.changes === 0) {
            return res.status(404).json({ error: 'Project not found' });
        }

        res.json({ success: true, message: 'Project deleted successfully' });
    } catch (err) {
        console.error('Delete project error:', err);
        res.status(500).json({ error: 'Failed to delete project' });
    }
});

// ========================================
// íŒŒì¼ ì—…ë¡œë“œ API
// ========================================

app.post('/api/upload', authenticateToken, upload.single('file'), (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ error: 'No file uploaded' });
        }

        const fileUrl = `http://localhost:${PORT}/uploads/${req.file.filename}`;
        res.json({ url: fileUrl, filename: req.file.filename });
    } catch (err) {
        console.error('Upload error:', err);
        res.status(500).json({ error: 'Failed to upload file' });
    }
});

// ========================================
// AI ì´ë¯¸ì§€ ìƒì„± API (OpenAI DALL-E)
// ========================================

app.post('/api/ai/generate-image', authenticateToken, async (req, res) => {
    try {
        const { prompt, size, quality } = req.body;

        if (!prompt) {
            return res.status(400).json({ error: 'Prompt is required' });
        }

        const openaiApiKey = process.env.OPENAI_API_KEY;
        if (!openaiApiKey) {
            return res.status(500).json({ error: 'OpenAI API key not configured' });
        }

        const response = await fetch('https://api.openai.com/v1/images/generations', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${openaiApiKey}`
            },
            body: JSON.stringify({
                model: 'dall-e-3',
                prompt: prompt,
                n: 1,
                size: size || '1024x1024',
                quality: quality || 'standard'
            })
        });

        const data = await response.json();

        if (!response.ok) {
            console.error('OpenAI API error:', data);
            return res.status(response.status).json({ 
                error: data.error?.message || 'Failed to generate image' 
            });
        }

        res.json({ imageUrl: data.data[0].url });
    } catch (err) {
        console.error('AI generation error:', err);
        res.status(500).json({ error: 'Failed to generate AI image' });
    }
});

// ========================================
// ë‚´ë³´ë‚´ê¸° API
// ========================================

const exportDir = path.join(__dirname, 'exports');
if (!fs.existsSync(exportDir)) {
    fs.mkdirSync(exportDir, { recursive: true });
}

app.use('/exports', express.static(exportDir));

// PNG ë‚´ë³´ë‚´ê¸°
app.post('/api/export/png', authenticateToken, (req, res) => {
    try {
        const { canvasData } = req.body;
        
        if (!canvasData) {
            return res.status(400).json({ error: 'Canvas data is required' });
        }

        const base64Data = canvasData.replace(/^data:image\/png;base64,/, '');
        const filename = `export-${Date.now()}.png`;
        const filepath = path.join(exportDir, filename);

        fs.writeFileSync(filepath, base64Data, 'base64');

        res.json({
            success: true,
            url: `http://localhost:${PORT}/exports/${filename}`,
            filename: filename
        });
    } catch (err) {
        console.error('PNG export error:', err);
        res.status(500).json({ error: 'Failed to export PNG' });
    }
});

// JPG ë‚´ë³´ë‚´ê¸°
app.post('/api/export/jpg', authenticateToken, (req, res) => {
    try {
        const { canvasData } = req.body;
        
        if (!canvasData) {
            return res.status(400).json({ error: 'Canvas data is required' });
        }

        const base64Data = canvasData.replace(/^data:image\/jpeg;base64,/, '');
        const filename = `export-${Date.now()}.jpg`;
        const filepath = path.join(exportDir, filename);

        fs.writeFileSync(filepath, base64Data, 'base64');

        res.json({
            success: true,
            url: `http://localhost:${PORT}/exports/${filename}`,
            filename: filename
        });
    } catch (err) {
        console.error('JPG export error:', err);
        res.status(500).json({ error: 'Failed to export JPG' });
    }
});

// SVG ë‚´ë³´ë‚´ê¸°
app.post('/api/export/svg', authenticateToken, (req, res) => {
    try {
        const { elements, width, height } = req.body;
        
        if (!elements) {
            return res.status(400).json({ error: 'Elements are required' });
        }

        let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">`;
        
        elements.forEach(el => {
            if (el.type === 'rectangle') {
                svgContent += `<rect x="${el.x}" y="${el.y}" width="${el.width}" height="${el.height}" fill="${el.fill}" opacity="${el.opacity || 1}" transform="rotate(${el.rotation || 0} ${el.x + el.width/2} ${el.y + el.height/2})"/>`;
            } else if (el.type === 'circle') {
                svgContent += `<circle cx="${el.x + el.width/2}" cy="${el.y + el.height/2}" r="${el.width/2}" fill="${el.fill}" opacity="${el.opacity || 1}"/>`;
            } else if (el.type === 'text') {
                svgContent += `<text x="${el.x}" y="${el.y}" font-size="${el.fontSize || 16}" fill="${el.fill}" opacity="${el.opacity || 1}">${el.text || ''}</text>`;
            }
        });
        
        svgContent += '</svg>';

        const filename = `export-${Date.now()}.svg`;
        const filepath = path.join(exportDir, filename);

        fs.writeFileSync(filepath, svgContent, 'utf8');

        res.json({
            success: true,
            url: `http://localhost:${PORT}/exports/${filename}`,
            filename: filename
        });
    } catch (err) {
        console.error('SVG export error:', err);
        res.status(500).json({ error: 'Failed to export SVG' });
    }
});

// ========================================
// HTML íŒŒì¼ ë¼ìš°íŠ¸ (ëª…ì‹œì )
// ========================================

app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, '../frontend', 'index.html'));
});

app.get('/login.html', (req, res) => {
    res.sendFile(path.join(__dirname, '../frontend', 'login.html'));
});

app.get('/index.html', (req, res) => {
    res.sendFile(path.join(__dirname, '../frontend', 'index.html'));
});

app.get('/editor.html', (req, res) => {
    res.sendFile(path.join(__dirname, '../frontend', 'editor.html'));
});

// ========================================
// ì„œë²„ ì‹œìž‘
// ========================================

const PORT = process.env.PORT || 3001;
const server = app.listen(PORT, () => {
    console.log(`ðŸš€ Server running on http://localhost:${PORT}`);
    console.log(`ðŸ“ Serving files from: ${path.join(__dirname, '../frontend')}`);
    console.log(`ðŸ“ Database: ${dbPath}`);
    console.log(`ðŸ“ Uploads: ${uploadsDir}`);
    console.log(`ðŸ“ Exports: ${exportDir}`);
});

// ========================================
// WebSocket ì„œë²„
// ========================================

const wss = new WebSocketServer({ server });

wss.on('connection', (ws) => {
    console.log('ðŸ‘¤ New WebSocket connection');

    ws.on('message', (message) => {
        try {
            const data = JSON.parse(message);
            
            // ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
            wss.clients.forEach((client) => {
                if (client !== ws && client.readyState === 1) {
                    client.send(JSON.stringify(data));
                }
            });
        } catch (err) {
            console.error('WebSocket message error:', err);
        }
    });

    ws.on('close', () => {
        console.log('ðŸ‘¤ WebSocket connection closed');
    });

    ws.on('error', (err) => {
        console.error('WebSocket error:', err);
    });
});

console.log('WebSocket server initialized');

// ========================================
// ì—ëŸ¬ í•¸ë“¤ë§
// ========================================

app.use((err, req, res, next) => {
    console.error('Server error:', err);
    res.status(500).json({ error: 'Internal server error' });
});

// Graceful shutdown
process.on('SIGTERM', () => {
    console.log('SIGTERM received, closing server...');
    server.close(() => {
        db.close();
        console.log('Server closed');
        process.exit(0);
    });
});

process.on('SIGINT', () => {
    console.log('SIGINT received, closing server...');
    server.close(() => {
        db.close();
        console.log('Server closed');
        process.exit(0);
    });
});